/*
 * Copyright 2010-2013 Robert J. Buck
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ----------------------------------------------------------------------------
// OPTIONS
// ----------------------------------------------------------------------------
options {
  STATIC = false;
  UNICODE_INPUT = true;
  //DEBUG_LOOKAHEAD= true;

  // some performance optimizations
  ERROR_REPORTING = false;
}

// ----------------------------------------------------------------------------
// PARSER
// ----------------------------------------------------------------------------

PARSER_BEGIN(SQLParser)
/*
 * Copyright 2010-2013 Robert J. Buck
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.buck.jsql;

import java.io.*;
import java.util.*;
import java.math.*;

import com.buck.jsql.expressions.conditional.*;
import com.buck.jsql.expressions.arithmetic.*;
import com.buck.jsql.identifiers.*;
import com.buck.jsql.literals.*;

/**
 * JMS Selector Expression Parser generated by JavaCC
 *
 * Do not edit this .java file directly - it is autogenerated from SQLParser.jj
 */
@SuppressWarnings({"FinalPrivateMethod", "RedundantIfStatement", "UnnecessarySemicolon", "ConstantIfStatement", "UnusedDeclaration", "JavaDoc"})
public class SQLParser {

    private final TreeMap<String, Identifier> identifiers = new TreeMap<String, Identifier>();

    public SQLParser() {
        this(new StringReader(""));
    }

    public class ParserState {
        private final Expression root;
        ParserState(Expression root) {
            this.root = root;
        }
        public Expression getRoot() {
            return root;
        }
        public Collection<Identifier> getIdentifiers() {
            return identifiers.values();
        }
    }

    public ParserState parse(String sql) throws InvalidQueryException {
        this.ReInit(new StringReader(sql));
        try {
            return new ParserState(SQLSearchCondition());
        } catch (Throwable e) {
          throw new InvalidQueryException(e);
        }
    }
}

PARSER_END(SQLParser)

/******************************************************************************
 * productions
 *****************************************************************************/

// ----------------------------------------------------------------------------
// Tokens
// ----------------------------------------------------------------------------

/* White Space */

SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */

SKIP:
{
  <LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:
{
  <BLOCK_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* Reserved Words */

TOKEN [IGNORE_CASE] :
{
    <  AND     : "and">
  | <  BETWEEN : "between">
  | <  IN      : "in">
  | <  IS      : "is">
  | <  LIKE    : "like">
  | <  NOT     : "not">
  | <  NULL    : "null" >
  | <  UNKNOWN : "unknown" >
  | <  OR      : "or">
  | <  ESCAPE  : "escape">
  | <  TRUE    : "true">
  | <  FALSE   : "false">
  | <  LT   : "<">
  | <  LE   : "<=">
  | <  EQ   : "=">
  | <  GE   : ">=">
  | <  GT   : ">">
  | <  NE   : "<>">
}

/* Literals */

TOKEN [IGNORE_CASE] :
{
    < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l","L"])? >
  | < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < OCTAL_LITERAL: "0" (["0"-"7"])* >
  | < FLOATING_POINT_LITERAL:
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? // matches: 5.5 or 5. or 5.5E10 or 5.E10
        | "." (["0"-"9"])+ (<EXPONENT>)?              // matches: .5 or .5E10
        | (["0"-"9"])+ <EXPONENT>                     // matches: 5E10
    >
  | < #EXPONENT: "E" (["+","-"])? (["0"-"9"])+ >
  | < STRING_LITERAL: "'" ( ("''") | ~["'"] )*  "'" >
  | < CHARACTER_LITERAL: "'" ( ("''") | ~["'"] )  "'" >
}

TOKEN [IGNORE_CASE] :
{
    < ID : ["a"-"z", "_", "$"] (["a"-"z","0"-"9","_", "$"])* >
}

/* Separators and operators */

TOKEN :
{
    < LPAREN: "(" >
  | < RPAREN: ")" >
  | < ASTERISK: "*" >
  | < SOLIDUS: "/" >
  | < MODULUS: "%" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < COMMA: "," >
}

// ----------------------------------------------------------------------------
// Productions
// ----------------------------------------------------------------------------

/**
 * SQL Spec. Section 8.12: <search condition>
 */
Expression SQLSearchCondition() :
{
    Expression u, v;
}
{
    u = SQLBooleanTerm()
    {
    }
    (
        <OR> v = SQLBooleanTerm()
        {
            u = new Or(u, v);
        }
    )*
    <EOF>
    {
        return u;
    }
}

Expression SQLBooleanTerm() :
{
    Expression u, v;
}
{
    u = SQLBooleanFactor()
    {
    }
    (
        <AND> v = SQLBooleanFactor()
        {
            u = new And(u, v);
        }
    )*
    {
        return u;
    }
}

Expression SQLBooleanFactor() :
{
    Expression u;
}
{
    (
        <NOT> u = SQLBooleanTest()
        {
            u = new Not(u);
        }
        |
        u = SQLBooleanTest()
        {
        }
    )
    {
        return u;
    }
}

Expression SQLBooleanTest() :
{
    Expression u, v;
}
{
    u = SQLBooleanPrimary()
    (
        <IS>
        (
            <NOT> v = SQLTruthValue()
            {
                u = new Not(new Comparison(Comparison.Operator.EQ, u, v));
            }
            |
            v = SQLTruthValue()
            {
                u = new Comparison(Comparison.Operator.EQ, u, v);
            }
        )
    )?
    {
        return u;
    }
}

Expression SQLBooleanPrimary() :
{
    Expression u;
}
{
    (
        LOOKAHEAD(3)
        <LPAREN> u = SQLSearchCondition() <RPAREN>
        {
        }
        |
        u = SQLPredicate()
        {
        }
    )
    {
        return u;
    }
}

Expression SQLTruthValue() :
{
    Expression u;
}
{
    (
        <TRUE>
        {
            u = new BooleanLiteral(Boolean.TRUE);
        }
        |
        <FALSE>
        {
            u = new BooleanLiteral(Boolean.FALSE);
        }
        |
        <UNKNOWN>
        {
            u = new BooleanLiteral(null);
        }
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 8.1 <predicate>
 */
Expression SQLPredicate() :
{
    Expression u, v, w;
    List<Expression> list;
    String s;
    Character c;
}
{
    u = SQLRowValueConstructor()
    (
        <NOT>
        (
            <BETWEEN> v = SQLRowValueConstructor() <AND> w = SQLRowValueConstructor()
            {
                u = new Not(new Between(u, v, w));
            }
            |
            <IN>
            <LPAREN>
            v = SQLValueExpr()
            {
                list = new ArrayList<Expression>();
                list.add( v );
            }
            (
                <COMMA> v = SQLValueExpr()
                {
                    list.add( v );
                }
            )*
            <RPAREN>
            {
                u = new In(u, list);
            }
            |
            {
                c = null;
            }
            <LIKE> s = SQLStringLiteral() [ <ESCAPE> c = SQLCharacterLiteral() ]
            {
                u = new Not(new Like(u, new PatternLiteral(s, c)));
            }
        )
        |
        /**
         * SQL Spec. Section 8.2: <comparison predicate>
         */
        <LT> v = SQLRowValueConstructor()
        {
            u = new Comparison(Comparison.Operator.LT, u, v);
        }
        |
        <LE> v = SQLRowValueConstructor()
        {
            u = new Comparison(Comparison.Operator.LE, u, v);
        }
        |
        <EQ> v = SQLRowValueConstructor()
        {
            u = new Comparison(Comparison.Operator.EQ, u, v);
        }
        |
        <GE> v = SQLRowValueConstructor()
        {
            u = new Comparison(Comparison.Operator.GE, u, v);
        }
        |
        <GT> v = SQLRowValueConstructor()
        {
            u = new Comparison(Comparison.Operator.GT, u, v);
        }
        |
        <NE> v = SQLRowValueConstructor()
        {
            u = new Comparison(Comparison.Operator.NE, u, v);
        }        
        |
        /**
         * SQL Spec. Section 8.3: <between predicate>
         */
        <BETWEEN> v = SQLRowValueConstructor() <AND> w = SQLRowValueConstructor()
        {
            u = new Between(u, v, w);
        }
        |
        /**
         * SQL Spec. Section 8.4: <in predicate>
         */
        <IN>
        <LPAREN>
        v = SQLValueExpr()
        {
            list = new ArrayList<Expression>();
            list.add( v );
        }
        (
            <COMMA> v = SQLValueExpr()
            {
                list.add( v );
            }
        )*
        <RPAREN>
        {
            u = new In(u, list);
        }
        /**
         * SQL Spec. Section 8.5: <like predicate>
         */
        |
        {
            c = null;
        }
        <LIKE> s = SQLStringLiteral() [ <ESCAPE> c = SQLCharacterLiteral() ]
        {
            u = new Like(u, new PatternLiteral(s, c));
        }
        |
        /**
         * SQL Spec. Section 8.6: <null predicate>
         */
        [LOOKAHEAD(3, (<IS> <NOT> <NULL> | <IS> <NULL>) )
        (
            <IS>
            (
                <NOT> <NULL>
                {
                    u = new Not(new Null(u));
                }
                |
                <NULL>
                {
                    u = new Null(u);
                }
            )
        )]
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 6.4  <column reference>
 *
 * @return the sub-expression
 */
Expression SQLColumnRef() :
{
    Token t;
    Expression u;
}
{
    (
        t = <ID>
        {
            final String identity = t.image.intern();
            Identifier id = identifiers.get(identity);
            if (id == null) {
                id = new Identifier(identity);
                identifiers.put(identity, id);
            }
            u = id;
        }
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 6.11  <value expression>
 */
Expression SQLValueExpr() :
{
    Expression u;
}
{
    (
        u = SQLStringValueExpr()
        {
        }
        |
        u = SQLNumericValueExpr()
        {
        }
    )
    {
        return u;
    }
}

Expression SQLValueExprPrimary() :
{
    Expression u;
}
{
    (
        u = SQLColumnRef()
        {
        }
        |
        u = SQLNumericLiteral()
        {
        }
        |
        <LPAREN> u = SQLValueExpr() <RPAREN>
        {
        }
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 6.12  <numeric value expression>
 */
Expression SQLNumericValueExpr() :
{
    Expression u, v;
}
{
    u = SQLTerm()
    (
        <PLUS> v = SQLTerm()
        {
            // addition
            u = new Add(u, v);
        }
        |
        <MINUS> v = SQLTerm()
        {
            // subtraction
            u = new Subtract(u, v);
        }
    )*
    {
        return u;
    }
}

Expression SQLTerm() :
{
    Expression u, v;
}
{
    u = SQLFactor()
    (
        <ASTERISK> v = SQLFactor()
        {
            // multiplication
            u = new Multiply(u, v);
        }
        |
        <SOLIDUS> v = SQLFactor()
        {
            // division
            u = new Divide(u, v);
        }
        |
        <MODULUS> v = SQLFactor()
        {
            // modulus
            u = new Modulus(u, v);
        }
    )*
    {
        return u;
    }
}

Expression SQLFactor() :
{
    Expression u;
}
{
    (
        <PLUS> u = SQLValueExprPrimary()
        {
            // positive
        }
        |
        <MINUS> u = SQLValueExprPrimary()
        {
            // negate
            u = new Negate(u);
        }
        |
        u = SQLValueExprPrimary()
        {
            // ordinary
        }
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 6.13  <string value expression>
 */
Expression SQLCharacterValueExpr() :
{
    Expression u;
}
{
    (

        u = SQLStringValueExpr()
        {
        }
        |
        u = SQLValueExprPrimary()
        {
        }
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 6.13  <string value expression>
 */
Expression SQLStringValueExpr() :
{
    Expression u;
    String s;
}
{
    (
        s = SQLStringLiteral()
        {
            u = new StringLiteral(s);
        }
    )
    {
        return u;
    }
}

/**
 * SQL Spec. Section 7.1  <row value constructor>
 */
Expression SQLRowValueConstructor() :
{
    Expression u;
}
{
    (
        u = SQLValueExpr()
        {
        }
        |
        u = SQLNullSpecification()
        {
        }
    )
    {
        return u;
    }
}

Expression SQLNullSpecification() :
{
    Expression u;
}
{
    (
        <NULL>
        {
            u = new BooleanLiteral(null);
        }
    )
    {
        return u;
    }
}

// LITERALS

Expression SQLNumericLiteral() :
{
    Token t;
    Expression u;
    Number lValue;
    Long longValue;
}
{
    (
        t = <DECIMAL_LITERAL>
        {
            String text = t.image;
            if(text.endsWith("l") || text.endsWith("L")) {
                text = text.substring(0, text.length() - 1);
            }

            try {
                lValue = new Long(text);
            } catch ( NumberFormatException e) {
                // The number may be too big to fit in a long.
                lValue = new BigDecimal(text);
            }

            longValue = lValue.longValue();
            if (Integer.MIN_VALUE <= longValue && longValue <= Integer.MAX_VALUE) {
                lValue = longValue.intValue();
            }
            u = new NumericLiteral(lValue);
        }
        |
        t = <FLOATING_POINT_LITERAL>
        {
            u = new DoubleLiteral(Double.parseDouble(t.image));
        }
        |
        t = <HEX_LITERAL>
        {
            lValue = Long.parseLong(t.image.substring(2), 16);
            longValue = lValue.longValue();
            if (Integer.MIN_VALUE <= longValue && longValue <= Integer.MAX_VALUE) {
                lValue = longValue.intValue();
            }
            u = new NumericLiteral(lValue);
        }
        |
        t = <OCTAL_LITERAL>
        {
            lValue = Long.parseLong(t.image, 8);
            longValue = lValue.longValue();
            if (Integer.MIN_VALUE <= longValue && longValue <= Integer.MAX_VALUE) {
                lValue = longValue.intValue();
            }
            u = new NumericLiteral(lValue);
        }
    )
    {
        return u;
    }
}

String SQLStringLiteral() :
{
    Token t;
    StringBuffer rc = new StringBuffer();
}
{
    (
        t = <STRING_LITERAL>
        {
            String image = t.image;
            for(int i = 1; i < image.length() - 1; i++) {
                char c = image.charAt(i);
                if( c == '\'' ) {
                    i++;
                }
                rc.append(c);
            }
        }
    )
    {
        return rc.toString();
    }
}

Character SQLCharacterLiteral() :
{
    Token t;
}
{
    t = <CHARACTER_LITERAL>
    {
        return t.image.charAt(0);
    }
}
